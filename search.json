[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Building Reproducible Analytical Pipelines",
    "section": "",
    "text": "Introduction\nThis is the 2025 edition of the course. If you‚Äôre looking for the 2024 edition, you can click here\nWhat‚Äôs new:\nThis course is based on my book titled Building Reproducible Analytical Pipelines with R. This course focuses only on certain aspects that are discussed in greater detail in the book.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#schedule",
    "href": "index.html#schedule",
    "title": "Building Reproducible Analytical Pipelines",
    "section": "Schedule",
    "text": "Schedule\n\n2025/09/04 - 4 hours,\n2025/09/11 - 4 hours,\n2025/09/14 - 4 hours,\n2025/09/02 - 4 hours,\n2025/09/05 - 2 hours,\n2025/09/09 - 5 hours,\n2025/09/16 - 4 hours,\n2025/09/19 - 3 hours,",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#reproducible-analytical-pipelines",
    "href": "index.html#reproducible-analytical-pipelines",
    "title": "Building Reproducible Analytical Pipelines",
    "section": "Reproducible analytical pipelines?",
    "text": "Reproducible analytical pipelines?\nThis course is my take on setting up code that results in some data product. This code has to be reproducible, documented and production ready. Not my original idea, but introduced by the UK‚Äôs Analysis Function.\nThe basic idea of a reproducible analytical pipeline (RAP) is to have code that always produces the same result when run, whatever this result might be. This is obviously crucial in research and science, but this is also the case in businesses that deal with data science/data-driven decision making etc.\nA well documented RAP avoids a lot of headache and is usually re-usable for other projects as well.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#data-products",
    "href": "index.html#data-products",
    "title": "Building Reproducible Analytical Pipelines",
    "section": "Data products?",
    "text": "Data products?\nIn this course each of you will develop a data product. A data product is anything that requires data as an input. This can be a very simple report in PDF or Word format or a complex web app. This website is actually also a data product, which I made using the R programming language. In this course we will not focus too much on how to create automated reports or web apps (but I‚Äôll give an introduction to these, don‚Äôt worry) but our focus will be on how to set up a pipeline that results in these data products in a reproducible way.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#machine-learning",
    "href": "index.html#machine-learning",
    "title": "Building Reproducible Analytical Pipelines",
    "section": "Machine learning?",
    "text": "Machine learning?\nNo, being a master in machine learning is not enough to become a data scientist. Actually, the older I get, the more I think that machine learning is almost optional. What is not optional is knowing how:\n\nto write, test, and properly document code;\nto acquire (reading in data can be tricky!) and clean data;\nto work inside the Linux terminal/command line interface;\nto use Git, Docker for Dev(Git)Ops;\nthe Internet works (what‚Äôs a firewall? what‚Äôs a reverse proxy? what‚Äôs a domain name? etc, etc‚Ä¶);\n\nBut what about machine learning? Well, depending what you‚Äôll end up doing, you might indeed focus a lot on machine learning and/or statistical modeling. That being said, in practice, it is very often much more efficient to let some automl algorithm figure out the best hyperparameters of a XGBoost model and simply use that, at least as a starting point (but good luck improving upon automl‚Ä¶). What matters, is that the data you‚Äôre feeding to your model is clean, that your analysis is sensible, and most importantly, that it could be understood by someone taking over (imagine you get sick) and rerun with minimal effort in the future. The model here should simply be a piece that could be replaced by another model without much impact. The model is rarely central‚Ä¶ but of course there are exceptions to this, especially in research, but every other point I‚Äôve made still stands. It‚Äôs just that not only do you have to care about your model a lot, you also have to care about everything else.\nSo in this course we‚Äôre going to learn a bit of all of this. We‚Äôre going to learn how to write reusable code, learn some basics of the Linux command line, Git and Docker.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#what-actually-is-reproducibility",
    "href": "index.html#what-actually-is-reproducibility",
    "title": "Building Reproducible Analytical Pipelines",
    "section": "What actually is reproducibility?",
    "text": "What actually is reproducibility?\nA reproducible project means that this project can be rerun by anyone at 0 (or very minimal) cost. But there are different levels of reproducibility, and I will discuss this in the next section. Let‚Äôs first discuss some requirements that a project must have to be considered a RAP.\n\nThe requirements of a RAP\nFor something to be truly reproducible, it has to respect the following bullet points:\n\nSource code must obviously be available and thoroughly tested and documented (which is why we will be using Git and Github);\nAll the dependencies must be easy to find and install (we are going to deal with this using dependency management tools);\nTo be written with an open source programming language (nocode tools like Excel are by default non-reproducible because they can‚Äôt be used non-interactively, and which is why we are going to use the R programming language);\nThe project needs to be run on an open source operating system (thankfully, we can deal with this without having to install and learn to use a new operating system, thanks to Docker);\nData and the paper/report need obviously to be accessible as well, if not publicly as is the case for research, then within your company.\n\nAlso, reproducibility is on a continuum, and depending on the constraints you face your project can be ‚Äúnot very reproducible‚Äù to ‚Äútotally reproducible‚Äù. Let‚Äôs consider the following list of anything that can influence how reproducible your project truly is:\n\nVersion of the programming language used;\nVersions of the packages/libraries of said programming language used;\nOperating System, and its version;\nVersions of the underlying system libraries (which often go hand in hand with OS version, but not necessarily).\nAnd even the hardware architecture that you run all that software stack on.\n\nSo by ‚Äúreproducibility is on a continuum‚Äù, what I mean is that you could set up your project in a way that none, one, two, three, four or all of the preceding items are taken into consideration when making your project reproducible.\nThis is not a novel, or new idea. Peng (2011) already discussed this concept but named it the reproducibility spectrum.\n\n\n\nThe reproducibility spectrum from Peng‚Äôs 2011 paper.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#large-language-models",
    "href": "index.html#large-language-models",
    "title": "Building Reproducible Analytical Pipelines",
    "section": "Large Language Models",
    "text": "Large Language Models\nLLMs have rapidly become an essential powertool in the data scientist‚Äôs toolbox. But as with any powertool, beginners risk cutting their fingers if they‚Äôre not careful. So it is important to learn how to use them. This course will give you some pointers on how to integrate LLMs into your workflow.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#why-r-why-not-insert-your-favourite-programming-language",
    "href": "index.html#why-r-why-not-insert-your-favourite-programming-language",
    "title": "Building Reproducible Analytical Pipelines",
    "section": "Why R? Why not [insert your favourite programming language]",
    "text": "Why R? Why not [insert your favourite programming language]\nR is a domain-specific language whose domain is statistics, data analysis/science and machine learning, and as such has many built-in facilities to make handling data very efficient.\nIf you learn R you have access to almost 25‚Äô000 packages (as of June 2025, including both CRAN and Bioconductor packages) to:\n\nclean data (see: {dplyr}, {tidyr}, {data.table}‚Ä¶);\nwork with medium and big data (see: {arrow}, {sparklyr}‚Ä¶);\nvisualize data (see: {ggplot2}, {plotly}, {echarts4r}‚Ä¶);\ndo literate programming (using Rmarkdown or Quarto, you can write books, documents even create a website);\ndo functional programming (see: {purrr}‚Ä¶);\ncall other languages from R (see: {reticulate} to call Python from R);\ndo machine learning and AI (see: {tidymodels}, {tensorflow}, {keras}‚Ä¶)\ncreate webapps (see: {shiny}‚Ä¶)\ndomain specific statistics/machine learning (see CRAN Task Views for an exhaustive list);\nand more\n\nIt‚Äôs not just about what the packages provide: installing R and its packages and dependencies is rarely frustrating, which is not the case with Python (Python 2 vs Python 3, pip vs conda, pyenv vs venv vs uv, ‚Ä¶, dependency hell is a real place full of snakes)\n\n\n\n\n\n\n\n\n\n\n\nThat doesn‚Äôt mean that R does not have any issues. Quite the contrary, R sometimes behaves in seemingly truly bizarre ways (as an example, try running nchar(\"1000000000\") and then nchar(1000000000) and try to make sense of it). To know more about such bizarre behaviour, I recommend you read The R Inferno (linked at the end of this chapter). So, yes, R is far from perfect, but it sucks less than the alternatives (again, in my absolutely objective opinion).\n\n  üü° Loading\n    webR...\n  \n    \n    \n      \n    \n  \n  \n  \n\n\nThat being said, the reality of data science is that the future is becoming more and more polyglot. Data products are evermore complex, and necessity are built using many languages; so ideally we would like to find a way to use whatever tool is best fit for the job at hand. Sometimes it can be R, sometimes Python, sometimes shell scripts, or any other language. This is where Nix will help us.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#nix",
    "href": "index.html#nix",
    "title": "Building Reproducible Analytical Pipelines",
    "section": "Nix",
    "text": "Nix\nNix is a package manager for Linux distributions, macOS and it even works on Windows if you enable WSL2. What‚Äôs a package manager? If you‚Äôre not a Linux user, you may not be aware. Let me explain it this way: in R, if you want to install a package to provide some functionality not included with a vanilla installation of R, you‚Äôd run this:\ninstall.packages(\"dplyr\")\nIt turns out that Linux distributions, like Ubuntu for example, work in a similar way, but for software that you‚Äôd usually install using an installer (at least on Windows). For example you could install Firefox on Ubuntu using:\nsudo apt-get install firefox\n(there‚Äôs also graphical interfaces that make this process ‚Äúmore user-friendly‚Äù). In Linux jargon, packages are simply what we call software (or I guess it‚Äôs all ‚Äúapps‚Äù these days). These packages get downloaded from so-called repositories (think of CRAN, the repository of R packages, or Pypi, in the case of Python) but for any type of software that you might need to make your computer work: web browsers, office suites, multimedia software and so on.\nSo Nix is just another package manager that you can use to install software.\nBut what interests us is not using Nix to install Firefox, but instead to install R, Python and the R and Python packages that we require for our analysis. But why use Nix instead of the usual ways to install software on our operating systems?\nThe first thing that you should know is that Nix‚Äôs repository, nixpkgs, is huge. Humongously huge. As I‚Äôm writing these lines, there‚Äôs more than 120‚Äô000 pieces of software available, and the entirety of CRAN and Bioconductor is also available through nixpkgs. So instead of installing R as you usually do and then use install.packages() to install packages, you could use Nix to handle everything. But still, why use Nix at all?\nNix has an interesting feature: using Nix, it is possible to install software in (relatively) isolated environments. So using Nix, you can install as many versions of R and R packages that you need. Suppose that you start working on a new project. As you start the project, with Nix, you would install a project-specific version of R and R packages that you would only use for that particular project. If you switch projects, you‚Äôd switch versions of R and R packages.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#pre-requisites",
    "href": "index.html#pre-requisites",
    "title": "Building Reproducible Analytical Pipelines",
    "section": "Pre-requisites",
    "text": "Pre-requisites\nI will assume basic programming knowledge, and not much more. Ideally you‚Äôll be following this course from a Linux machine, but if you‚Äôre macOS, that‚Äôs fine as well. On Windows, you will have to set up WSL2 to follow along.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#grading",
    "href": "index.html#grading",
    "title": "Building Reproducible Analytical Pipelines",
    "section": "Grading",
    "text": "Grading\nThe way grading works in this course is as follows: during lecture hours you will follow along. At home, you‚Äôll be working on setting up your own pipeline. For this, choose a dataset that ideally would need some cleaning and/or tweaking to be usable. We are going first to learn how to package this dataset alongside some functions to make it clean. If time allows, I‚Äôll leave some time during lecture hours for you to work on it and ask me and your colleagues for help. At the end of the semester, I will need to download your code and get it running. The less effort this takes me, the better your score. Here is a tentative breakdown:\n\nCode is on github.com and the repository is documented with a Readme.md file: 5 points;\nData and functions to run pipeline are documented and tested: 5 points;\nEvery software dependency is easily installed: 5 points;\nPipeline can be executed in one command: 5 points;\nBonus points: pipeline is dockerized, or uses Nix, and/or uses Github Actions to run? 5 points\n\nThe way to fail this class is to write an undocumented script that only runs on your machine and expect me to debug it to get it to run.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#jargon",
    "href": "index.html#jargon",
    "title": "Building Reproducible Analytical Pipelines",
    "section": "Jargon",
    "text": "Jargon\nThere‚Äôs some jargon that is helpful to know when working with R. Here‚Äôs a non-exhaustive list to get you started:\n\nCRAN: the Comprehensive R Archive Network. This is a curated online repository of packages and R installers. When you type install.packages(\"package_name\") in an R console, the package gets downloaded from there;\nLibrary: the collection of R packages installed on your machine;\nR console: the program where the R interpreter runs;\nPosit/RStudio: Posit (named RStudio in the past) are the makers of the RStudio IDE and of the tidyverse collection of packages;\ntidyverse: a collection of packages created by Posit that offer a common language and syntax to perform any task required for data science ‚Äî from reading in data, to cleaning data, up to machine learning and visualisation;\nbase R: refers to a vanilla installation (and vanilla capabilities) of R. Often used to contrast a tidyverse specific approach to a problem (for example, using base R‚Äôs lapply() in constrast to the tidyverse purrr::map()).\npackage::function(): Functions can be accessed in several ways in R, either by loading an entire package at the start of a script with library(dplyr) or by using dplyr::select().\nFunction factory (sometimes adverb): a function that returns a function.\nVariable: the variable of a function (as in x in f(x)) or the variable from statistical modeling (synonym of feature)\n&lt;- vs =: in practice, you can use &lt;- and = interchangeably. I prefer &lt;-, but feel free to use = if you wish.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#further-reading",
    "href": "index.html#further-reading",
    "title": "Building Reproducible Analytical Pipelines",
    "section": "Further reading",
    "text": "Further reading\n\nAn Introduction to R (from the R team themselves)\nWhat is CRAN?\nThe R Inferno\nBuilding Reproducible Analytical Pipelines with R\nReproducible Analytical Pipelines (RAP)",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Building Reproducible Analytical Pipelines",
    "section": "License",
    "text": "License\nThis course is licensed under the WTFPL.\n\n\n\n\n\nPeng, Roger D. 2011. ‚ÄúReproducible Research in Computational Science.‚Äù Science 334 (6060): 1226‚Äì27.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "02-intro-nix.html",
    "href": "02-intro-nix.html",
    "title": "1¬† Reproducibility with Nix",
    "section": "",
    "text": "1.1 Learning Outcomes (Day 1)\nBy the end of Day 1, you will:",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Reproducibility with Nix</span>"
    ]
  },
  {
    "objectID": "02-intro-nix.html#learning-outcomes-day-1",
    "href": "02-intro-nix.html#learning-outcomes-day-1",
    "title": "1¬† Reproducibility with Nix",
    "section": "",
    "text": "Understand the need for environment reproducibility in modern workflows\nInstall and configure Nix\nUse {rix} to generate default.nix files\nBuild cross-language environments for data work or software development",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Reproducibility with Nix</span>"
    ]
  },
  {
    "objectID": "02-intro-nix.html#why-reproducibility-why-nix-2h",
    "href": "02-intro-nix.html#why-reproducibility-why-nix-2h",
    "title": "1¬† Reproducibility with Nix",
    "section": "1.2 Why Reproducibility? Why Nix? (2h)",
    "text": "1.2 Why Reproducibility? Why Nix? (2h)\n\n1.2.1 Motivation: Reproducibility in Scientific and Data Workflows\nTo ensure that a project is reproducible you need to deal with at least four things:\n\nMake sure that the required/correct version of R (or any other language) is installed;\nMake sure that the required versions of packages are installed;\nMake sure that system dependencies are installed (for example, you‚Äôd need a working Java installation to install the rJava R package on Linux);\nMake sure that you can install all of this for the hardware you have on hand.\n\nBut in practice, one or most of these bullet points are missing from projects. The goal of this course is to learn how to fullfill all the requirements to build reproducible projects.\n\n\n1.2.2 Problems with Ad-Hoc Tools\nTools like Python‚Äôs venv or R‚Äôs renv only deal with some pieces of the reproducibility puzzle. Often, they assume an underlying OS, do not capture native system dependencies (like libxml2, pandoc, or curl), and require users to ‚Äúrebuild‚Äù their environments from partial metadata. Docker helps but introduces overhead, security challenges, and complexity.\nTraditional approaches fail to capture the entire dependency graph of a project in a deterministic way. This leads to ‚Äúit works on my machine‚Äù syndromes, onboarding delays, and subtle bugs.\n\n\n1.2.3 Installing and Using Nix\nNix is a tool for reproducible builds and development environments, often introduced as a package manager. It captures complete dependency trees, from your programming language interpreter to every system-level library you rely on. With Nix, environments are not recreated from documentation, but rebuilt precisely from code.\nNix can be installed on Linux distributions, macOS and it even works on Windows if you enable WSL2. In this course, we will use Nix mostly as a package manager (but towards the end also as a build automatino tool).\nWhat‚Äôs a package manager? If you‚Äôre not a Linux user, you may not know. Let me explain it this way: in R, if you want to install a package to provide some functionality not included with a vanilla installation of R, you‚Äôd run this:\ninstall.packages(\"dplyr\")\nIt turns out that Linux distributions, like Ubuntu for example, work in a similar way, but for software that you‚Äôd usually install using an installer (at least on Windows). For example you could install Firefox on Ubuntu using:\nsudo apt-get install firefox\n(there‚Äôs also graphical interfaces that make this process ‚Äúmore user-friendly‚Äù). In Linux jargon, packages are simply what we call software (or I guess it‚Äôs all ‚Äúapps‚Äù these days). These packages get downloaded from so-called repositories (think of CRAN, the repository of R packages) but for any type of software that you might need to make your computer work: web browsers, office suites, multimedia software and so on.\nSo Nix is just another package manager that you can use to install software.\nBut what interests us is not using Nix to install Firefox, but instead to install R and the R packages that we require for our analysis (or any other programming language that we need). But why use Nix instead of the usual ways to install software on our operating systems?\nThe first thing that you should know is that Nix‚Äôs repository, nixpkgs, is huge. Humongously huge. As I‚Äôm writing these lines, there‚Äôs more than 120‚Äô000 pieces of software available, and the entirety of CRAN and Bioconductor is also available through nixpkgs. So instead of installing R as you usually do and then use install.packages() to install packages, you could use Nix to handle everything. But still, why use Nix at all?\nNix has an interesting feature: using Nix, it is possible to install software in (relatively) isolated environments. So using Nix, you can install as many versions of R and R packages that you need. Suppose that you start working on a new project. As you start the project, with Nix, you would install a project-specific version of R and R packages that you would only use for that particular project. If you switch projects, you‚Äôd switch versions of R and R packages.\nHowever Nix has quite a steep learning curve, so this is why for the purposes of this course we are going to use an R package called {rix} to set up reproducible environments.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Reproducibility with Nix</span>"
    ]
  },
  {
    "objectID": "02-intro-nix.html#rix-workflow",
    "href": "02-intro-nix.html#rix-workflow",
    "title": "1¬† Reproducibility with Nix",
    "section": "1.3 rix workflow",
    "text": "1.3 rix workflow\nThe idea of {rix} is for you to declare the environment you need using the provided rix() function. rix() is the package‚Äôs main function and generates a file called default.nix which is then used by the Nix package manager to build that environment. Ideally, you would set up such an environment for each of your projects. You can then use this environment to either work interactively, or run R or Python scripts. It is possible to have as many environments as projects, and software that is common to environments will simply be re-used and not get re-installed to save space. Environments are isolated for each other, but can still interact with your system‚Äôs files, unlike with Docker where a volume must be mounted. Environments can also interact with the software installed on your computer through the usual means, which can sometimes lead to issues. For example, if you already have R installed, and a user library of R packages, more caution is required to properly use environments managed by Nix.\nYou don‚Äôt need to have R‚ÄØinstalled or be an R user to use {rix}. If you have Nix installed on your system, it is possible to ‚Äúdrop‚Äù into a temporary environment with R and {rix} available and generate the required Nix expression from there.\nBut first, let‚Äôs install Nix and try to use temporary shells.\n\n1.3.1 Installing Nix\n\n1.3.1.1 Windows pre-requisites\nIf you are on Windows, you need the Windows Subsystem for Linux 2 (WSL2) to run Nix. If you are on a recent version of Windows 10 or 11, you can simply run this as an administrator in PowerShell:\nwsl --install\nYou can find further installation notes at this official MS documentation.\nWe recommend to activate systemd in Ubuntu WSL2, mainly because this supports other users than root running Nix. To set this up, please do as outlined this official Ubuntu blog entry:\n\n# in WSL2 Ubuntu shell\n\nsudo -i\nnano /etc/wsl.conf\nThis will open the /etc/wsl.conf in a nano, a command line text editor. Add the following line:\n[boot]\nsystemd=true\nSave the file with CTRL-O and then quit nano with CTRL-X. Then, type the following line in powershell:\nwsl --shutdown\nand then relaunch WSL (Ubuntu) from the start menu.\nAfterwards, you can install Nix like business as usual. You can proceed with the Determinate Systems installer.\n\n\n\n1.3.2 Using the Determinate Systems installer\nYou can use {rix} to generate Nix expressions even if you don‚Äôt have Nix installed on your system, but obviously, you need to install Nix if you actually want to build the defined development environment and use them.\nInstalling (and uninstalling) Nix is quite simple, thanks to the installer from Determinate Systems, a company that provides services and tools built on Nix, and works the same way on Linux (native or WSL2) and macOS.\nDo not use your operating system‚Äôs package manager to install Nix. Instead, simply open a terminal and run the following line (on Windows, if you cannot or have decided not to activate systemd, then you have to append --init none to the command. You can find more details about this on The Determinate Nix Installer page):\n\ncurl --proto '=https' --tlsv1.2 -sSf \\\n    -L https://install.determinate.systems/nix | \\\n     sh -s -- install\n\nThen, install the cachix client and configure the rstats-on-nix cache: this will install binary versions of many R packages which will speed up the building process of environments:\nnix-env -iA cachix -f https://cachix.org/api/v1/install\nthen use the cache:\ncachix use rstats-on-nix\nYou only need to do this once per machine you want to use {rix} on. Many thanks to Cachix for sponsoring the rstats-on-nix cache!\n\n\n1.3.3 Temporary shells\nYou now have Nix installed; before continuing, it let‚Äôs see if everything works (close all your terminals and reopen them) by droping into a temporary shell with a tool you likely have not installed on your machine.\nOpen a terminal and run:\nwhich sl\nyou will likely see something like this:\nwhich: no sl in ....\nnow run this:\nnix-shell -p sl\nand then again:\nwhich sl\nthis time you should see something like:\n/nix/store/cndqpx74312xkrrgp842ifinkd4cg89g-sl-5.05/bin/sl\nThis is the path to the sl binary installed through Nix. The path starts with /nix/store: the Nix store is where all the software installed through Nix is stored. Now type sl and see what happens!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Reproducibility with Nix</span>"
    ]
  },
  {
    "objectID": "02-intro-nix.html#session-1.2-dev-environments-with-nix-2h",
    "href": "02-intro-nix.html#session-1.2-dev-environments-with-nix-2h",
    "title": "1¬† Reproducibility with Nix",
    "section": "1.4 Session 1.2 ‚Äì Dev Environments with Nix (2h)",
    "text": "1.4 Session 1.2 ‚Äì Dev Environments with Nix (2h)\n\n1.4.1 Using {rix} to generate development environments\n\n\n1.4.2 Using nix-shell to Launch Environments\nOnce your file is in place, simply run:\nnix-shell\nThis gives you an isolated shell session with all declared packages available. You can test code, explore APIs, or install further tools within this session.\n\n\n1.4.3 Pinning with nixpkgs\nTo ensure long-term reproducibility, pin the version of Nixpkgs used. Replace &lt;nixpkgs&gt; with a fixed import:\nlet\n  pkgs = import (fetchTarball \"https://github.com/rstats-on-nix/nixpkgs/archive/2025-06-02.tar.gz\") {};\nin\npkgs.mkShell {\n  buildInputs = [ pkgs.r pkgs.rPackages.dplyr ];\n}\nThis avoids unexpected updates and lets others reproduce your environment exactly.\n\n\n1.4.4 Hands-On Exercises\n\nExtend your previous shell.nix to add r and rPackages.dplyr\nAdd Python with numpy and pytest\nWrite a one-liner R and Python script and run them inside nix-shell\nShare your folder with a partner; verify their shell behaves identically\nPin your nixpkgs version and commit the change",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Reproducibility with Nix</span>"
    ]
  }
]