---
filters:
  - webr
webr:
  packages: ['dplyr']
---

# Reproducibility with Nix

<div style="text-align:center;">
```{r, echo = F}
knitr::include_graphics("img/Nix_Snowflake_Logo.png")
```
</div>

## Learning Outcomes

By the end of this chapter, you will:

- Understand the need for environment reproducibility in modern workflows
- Use `{rix}` to generate `default.nix` files
- Build cross-language environments for data work or software development

## Why Reproducibility? Why Nix? *(1h30)*

### Motivation: Reproducibility in Scientific and Data Workflows

To ensure that a project is reproducible you need to deal with at least four
things:

- Make sure that the required/correct version of R (or any other language) is
  installed;
- Make sure that the required versions of packages are installed;
- Make sure that system dependencies are installed (for example, you’d need a
  working Java installation to install the `{rJava}` R package on Linux);
- Make sure that you can install all of this for the hardware you have on hand.

But in practice, one or most of these bullet points are missing from projects.
The goal of this course is to learn how to fullfill all the requirements to
build reproducible projects.

### Problems with Ad-Hoc Tools

Tools like Python's `venv` or R's `renv` only deal with some pieces of the
reproducibility puzzle. Often, they assume an underlying OS, do not capture
system-level dependencies (like `libxml2`, `pandoc`, or `curl`), and require
users to "rebuild" their environments from partial metadata. Docker helps but
introduces overhead, security challenges, and complexity, and just adding it to
your project doesn’t make it reproducible if you don’t explicitely take some
precautionary steps.

Traditional approaches fail to capture the entire dependency graph of a project
in a deterministic way. This leads to "it works on my machine" syndromes,
onboarding delays, and subtle bugs.

### Nix, a declarative package manager

Nix is a tool for reproducible builds and development environments, often
introduced as a package manager. It captures complete dependency trees, from
your programming language interpreter to every system-level library you rely on.
With Nix, environments are not recreated from documentation, but rebuilt
precisely from code.

Nix can be installed on Linux distributions, macOS and it even works on Windows
if you enable WSL2. In this course, we will use Nix mostly as a package manager
(but towards also as a build automation tool).

However Nix has quite a steep learning curve, so this is why for the purposes of
this course we are going to use an R package called `{rix}` to set up
reproducible environments.

### The rix package

`{rix}` is an R package (I’m the author) and its goal is to make writing Nix
expressions easy. With `{rix}` you can declare the environment you need using the
provided `rix()` function, which is the package's main function. Calling it
generates a file called `default.nix` which is then used by the Nix package
manager to build that environment. Ideally, you would set up such an environment
for each of your projects. You can then use this environment to either work
interactively, or run R or Python scripts. It is possible to have as many
environments as projects, and software that is common to environments will
simply be re-used and not get re-installed to save space. Environments are
isolated from each other, but can still interact with your system's files, unlike
with Docker where a volume must be mounted. While this is useful, it can
sometimes lead to issues. For example, if you already have R installed, and a
user library of R packages, more caution is required to properly use
environments managed by Nix.

You don’t need to have R installed or be an R user to use `{rix}`. If you have
Nix installed on your system, it is possible to "drop" into a temporary
environment with R and `{rix}` available and generate the required Nix
expression from there.

But first, let’s install Nix and try to use temporary shells.

### Installing Nix

#### For Windows users only: some prerequisites

If you are on Windows, you need the Windows Subsystem for Linux 2 (WSL2) to run
Nix. If you are on a recent version of Windows 10 or 11, you can simply run this
as an administrator in PowerShell:

```sh
wsl --install
```

You can find further installation notes at [this official MS
documentation](https://learn.microsoft.com/en-us/windows/wsl/install).

I recommend to activate `systemd` in Ubuntu WSL2, mainly because this supports
other users than `root` running Nix. To set this up, please do as outlined [this
official Ubuntu blog entry](https://ubuntu.com/blog/ubuntu-wsl-enable-systemd):

```sh
# in WSL2 Ubuntu shell

sudo -i
nano /etc/wsl.conf
```

This will open the `/etc/wsl.conf` in a nano, a command line text editor. Add
the following line:

```toml
[boot]
systemd=true
```

Save the file with CTRL-O and then quit nano with CTRL-X.
Then, type the following line in powershell:

```sh
wsl --shutdown
```

and then relaunch WSL (Ubuntu) from the start menu. For those of you running
Windows, we will be working exclusively from WSL2 now. If that is not an option,
then I highly recommend you set up a virtual machine with Ubuntu using
[VirtualBox](https://www.virtualbox.org/wiki/Downloads) for example, or
dual-boot Ubuntu.

Installing (and uninstalling) Nix is quite simple, thanks to the installer from
[Determinate
Systems](https://github.com/DeterminateSystems/nix-installer), a company
that provides services and tools built on Nix, and works the same way on Linux
(native or WSL2) and macOS.

#### Actually installing Nix

Do not use your operating system’s package manager to install Nix. Instead,
simply open a terminal and run the following line (on Windows, run this inside
WSL):

```{sh parsermd-chunk-1, eval = FALSE}
curl --proto '=https' --tlsv1.2 -sSf \
  -L https://install.determinate.systems/nix | \
  sh -s -- install
```

Then, install the `cachix` client and configure the `rstats-on-nix` cache: this
will install binary versions of many R packages which will speed up the building
process of environments:

```bash
nix-env -iA cachix -f https://cachix.org/api/v1/install
```

then use the cache:

```bash
cachix use rstats-on-nix
```

You only need to do this once per machine you want to use `{rix}` on. Many
thanks to [Cachix](https://www.cachix.org/) for sponsoring the `rstats-on-nix`
cache!

If you get this warning when trying to install software with Nix:

```
warning: ignoring the client-specified setting 'trusted-public-keys', because it is a restricted setting and you are not a trusted user
warning: ignoring untrusted substituter 'https://rstats-on-nix.cachix.org', you are not a trusted user.
Run `man nix.conf` for more information on the `substituters` configuration option.
warning: ignoring the client-specified setting 'trusted-public-keys', because it is a restricted setting and you are not a trusted user
```

Then this means that configuration was not successful. You need to add your user to `/etc/nix/nix.custom.conf`:

```
sudo vim /etc/nix/nix.custom.conf
```

then simply add this line in the file:

```
trusted-users = root YOURUSERNAME
```

where `YOURUSERNAME` is your current login user name.

### Temporary shells

You now have Nix installed; before continuing, it let’s see if everything works
(close all your terminals and reopen them) by droping into a temporary shell
with a tool you likely have not installed on your machine.

Open a terminal and run:

```bash
which sl
```

you will likely see something like this:

```bash
which: no sl in ....
```

now run this:

```bash
nix-shell -p sl
```

and then again:

```bash
which sl
```

this time you should see something like:

```bash
/nix/store/cndqpx74312xkrrgp842ifinkd4cg89g-sl-5.05/bin/sl
```

This is the path to the `sl` binary installed through Nix. The path starts with
`/nix/store`: the *Nix store* is where all the software installed through Nix is
stored. Now type `sl` and see what happens!

You can find the list of available packages
[here](https://search.nixos.org/packages?channel=unstable&from=0&size=50&sort=relevance&type=packages&query=).

## Session 1.2 – Dev Environments with Nix *(1h30)*

### Some Nix concepts

While temporary shells are useful for quick testing, this is not how Nix is
typically used in practice. Nix is a declarative package manager: users specify
what they want to build, and Nix takes care of the rest.

To do so, users write files called `default.nix` that contain the a so-called
Nix expression. This expression will contain the definition of a (or several)
*derivations*.

In `Nix` terminology, a derivation is *a specification for running an executable
on precisely defined input files to repeatably produce output files at uniquely
determined file system paths.*
([source](https://nix.dev/manual/nix/2.25/language/derivations))

In simpler terms, a derivation is a recipe with precisely defined inputs, steps,
and a fixed output. This means that given identical inputs and build steps, the
exact same output will always be produced. To achieve this level of
reproducibility, several important measures must be taken:

- All inputs to a derivation must be explicitly declared.
- Inputs include not just data files, but also software dependencies,
  configuration flags, and environment variables, essentially anything necessary
  for the build process.
- The build process takes place in a *hermetic* sandbox to ensure the exact same
  output is always produced.

The next sections of this document explain these three points in more detail.

### Derivations

Here is an example of a *simple* `Nix` expression:

```nix
let

 pkgs = import (fetchTarball "https://github.com/rstats-on-nix/nixpkgs/archive/2025-04-11.tar.gz") {};

in

pkgs.stdenv.mkDerivation {
  name = "filtered_mtcars";
  buildInputs = [ pkgs.gawk ];
  dontUnpack = true;
  src = ./mtcars.csv;
  installPhase = ''
    mkdir -p $out
    awk -F',' 'NR==1 || $9=="1" { print }' $src > $out/filtered.csv
  '';
}
```

I won't go into details here, but what's important is that this code uses `awk`,
a common Unix data processing tool, to filter the `mtcars.csv` file to keep only
rows where the 9th column (the `am` column) equals 1. As you can see, a
significant amount of boilerplate code is required to perform this simple
operation. However, this approach is completely reproducible: the dependencies
are declared and pinned to a specific dated branch of our
`rstats-on-nix/nixpkgs` fork (more on this later), and the only thing that could
make this pipeline fail (though it's a bit of a stretch to call this a
*pipeline*) is if the `mtcars.csv` file is not provided to it. This expression
can be *instantiated* into a derivation, and the derivation is then built into
the actual output that interests us, namely the filtered `mtcars` data.

The derivation above uses the `Nix` builtin function `mkDerivation`: as its name
implies, this function *makes a derivation*. But there is also `mkShell`, which
is the function that builds a shell instead. Nix expressions that built a shell
is the kind of expressions `{rix}` generates for you.

###  Using `{rix}` to generate development environments

If you have successfully installed Nix, but don't have yet R installed on your
system, you could install R as you would usually do on your operating system,
and then install the `{rix}` package, and from there, generate project-specific
expressions and build them. But you could also install R using Nix. Actually, I
would even recommend you uninstall R and delete all your packages from your
computer and only manager R environments using Nix.

Running the following line in a terminal will drop you in an interactive R
session that you can use to start generating expressions:

```bash
nix-shell -p R rPackages.rix
```

This will drop you in a temporary shell with R and `{rix}` available. Navigate
to an empty directory to help a project, call it `rix-session-1`:

```bash
mkdir rix-session-1
```

and start R and load `{rix}`:

```bash
R
```

```r
library(rix)
```

you can now generate an expression by running the following code:

```r
rix(
  date = "2025-08-04",
  r_pkgs = c("dplyr", "ggplot2"), # add languageserver if you plan to use VS Code
  py_conf = list(
    py_version = "3.13",
    py_pkgs = c("polars", "great-tables")
  ),
  ide = "positron",
  project_path = ".",
  overwrite = TRUE
)
```

This will write a file called `default.nix` in your project’s directory. This
`default.nix` contains a Nix expression which will build a shell that comes with
R, `{dplyr}` and `{ggplot2}` as they were on the the 4th of August 2025 on CRAN.
This will also add Python 3.13 and the `ploars` and `great-tables` Python
packages as they were at the time in `nixpkgs` (more on this later). Finally,
this also add the Positron IDE, which is a fork of VS Code for data science.
This is just an example, and you can use another IDE if you wish. See this
[vignette](https://docs.ropensci.org/rix/articles/e-configuring-ide.html) for
learning how to setup your IDE with Nix.

### Using `nix-shell` to Launch Environments

Once your file is in place, simply run:

```bash
nix-shell
```

This gives you an isolated shell session with all declared packages available.
You can test code, explore APIs, or install further tools within this session.

To remove the packages that were installed, call `nix-store --gc`. This will
call the garbage collector. If you want to avoid that an environment gets
garbage-collected, use `nix-build` instead of `nix-shell`. This will create a
symlink called `result` in your project’s root directory and `nix-store --gc`
won’t garbage-collect this environment until you manually remove `result`.

### Pinning with `nixpkgs`

To ensure long-term reproducibility, a pinned the version of Nixpkgs is used:

```nix
let
  pkgs = import (fetchTarball "https://github.com/rstats-on-nix/nixpkgs/archive/2025-08-04.tar.gz") {};
in
...
```

This is done automatically by `{rix}`. You could change the date manually if you
prefer, but I would recommend to always regenerate the `default.nix` using
`{rix}`.

### Installing Python packages not available via nixpkgs (impure)

Not all Python packages can be installed through Nix; unlike CRAN, Pypi doesn’t
get automatically mirrored and individual packages fixed by volunteers. Instead, specific Python
packages get packaged individually for Nix. Thus, it could very well be the case that a specific
Python package (or version of a Python package) that you need for a project is not 
available via nixpkgs.

In this case, it is still possible to use Python-specific package managers, like `uv`, 
to install packages. This is also useful if you work on a project with colleagues that 
use `uv` and that don’t want (yet) to use Nix. `uv`, is 10-100x faster than `pip` and
also generates a lock file for improved reproducibility.

The idea is to install `uv` in your shell (but not any Python nor Python packages):

```{r, eval = F}
rix(
  ...
  system_pkgs = c("uv"),
  ...
)
```

And then use `uv` from your shell as you would usually. We recommend specifying Python packages
in a `requirements.txt` file, and specifying explicit versions (e.g., `scanpy==1.11.4`).
Finally, we also recommend setting a shell hook to set up the virtual environment and install
the packages from the `requirements.txt` when entering the shell (mind the quotes):

```r
rix(
  ...
  system_pkgs = c("uv"),
  shell_hook = "
      if [ ! -f pyproject.toml ]; then
        uv init --python 3.13.5 # or whichever Python version you need
      fi
        uv add --requirements requirements.txt
      # Create alias so python uses uvs environment
      alias python='uv run python'
  ",
)
```

After running `nix-shell`, `uv` should initalize a Python project with the specified Python version
and install the packages listed in `requirements.txt` within the nix environment. 
This will take place each time `nix-shell` is called, however this will be cached and not installed each time.

To make sure everything works fine, you could simply start a Python interpreter and try to load
`numpy`. This should work fine, but if it doesn’t, the following error could be raised:

```bash
ImportError:

IMPORTANT: PLEASE READ THIS FOR ADVICE ON HOW TO SOLVE THIS ISSUE!

Importing the numpy C-extensions failed. This error can happen for
many reasons, often due to issues with your setup or how NumPy was
installed.

We have compiled some common reasons and troubleshooting tips at:

    https://numpy.org/devdocs/user/troubleshooting-importerror.html

Please note and check the following:

  * The Python version is: Python3.13 from "/home/user/projects/rix_uv/.venv/bin/python3"
  * The NumPy version is: "2.2.6"

and make sure that they are the versions you expect. Please carefully study the
documentation linked above for further help.

Original error was: libstdc++.so.6: cannot open shared object file: No such file or directory
```

That is an issue when using *wheels* (wheels are binaries of Python packages
that get installed by default using `uv`). These wheels expect certain libraries to be 
in certain places. One way to solve this is to add the following to your shell hook:

```r
shellHook = ''
   # Export LD_LIBRARY is required for python packages that dynamically load libraries, such as numpy 
   export LD_LIBRARY_PATH="${pkgs.lib.makeLibraryPath (with pkgs; [ zlib gcc.cc glibc stdenv.cc.cc ])}":LD_LIBRARY_PATH;
   ...
```

Your environment should now work.

If this seems complicated: yes, and that is actually exactly the type of
problems that Nix aims to solve. However, there are just too many Python
packages to automate their inclusion into nixpkgs like how it’s done for R. If
you can, prefer using the Python packages included in nixpkgs.


## Configuring your IDE

We now need to configure an IDE to use both our Nix shells as development
environments, and GitHub Copilot. You are free to use whatever IDE
you want but the instructions below are going to focus on RStudio, VS Code
and Positron.

The following are the setups we recommend you use to work using an IDE and Nix
environments. To be recommended, a setup should:

- be easy to setup;
- work the same on any operating system;
- not require any type of special maintenance.

Regardless of your operating system, a general-purpose editor such as VS Code
(or Codium), Emacs, or Neovim meets the above requirements. Recent releases of
Positron also work quite well. However, some editors
perform better on certain platforms.

Also, we recommend you uninstall R if it's installed system-wide and also remove
your local library of packages and instead only use dedicated Nix shells to
manage your projects. While we made our possible for Nix shells to not interfere
with a system-installed R, we recommend users go into the habit of taking some
minutes at the start of a project to properly set up their development
environment.

### Recommended setup on macOS

On macOS, RStudio will only be available through Nix and only for versions 4.4.3
or more recent, or after the 2025-02-28 if you're using dates. For older
versions of R or dates, RStudio is not available for macOS through Nix so you
cannot use it. As such, we recommend either VS Code (or Codium) or Positron for
older dates or versions. Emacs or Neovim are also good options. See the relevant
sections below to set up any of these editors. We also recommend to install the
editor on macOS directly, and configure it to interact with Nix shells, instead
of using Nix to install the editor, even though it does take some more effort to
configure.

### Recommended setup on Windows

On Windows, since you have to use Nix through WSL, your options are limited to
editors that either:

- can be installed on Windows and interact with WSL, or
- can be launched directly from WSL.

We recommend to use an editor you can install directly on Windows and configure
to interact nicely with WSL, and it turns out that this is mostly only VS Code
(or Codium) or Positron. See
[this section](#configuring-native-vs-codecodium-on-your-operating-system)
to learn how to configure VS Code (or Codium) or Positron.

If you want to use RStudio, this is also possible but:

- RStudio should ideally be installed with Nix inside WSL;
- your version of Windows needs to support
  [WSLg](https://learn.microsoft.com/en-us/windows/wsl/tutorials/gui-apps) which
  should be fine on Windows 11 or the very latest Windows 10 builds. WSLg allows
  you to run GUI apps from WSL.

You should also be aware that there is currently a bug in the RStudio Nix
package that makes RStudio ignore project-specific `.Rprofile` files, which can
be an issue if you also have a system-level library of packages. Instead, you
can sure the `.Rprofile` generated by `rix()` yourself or you can uninstall the
system-level R and library of packages.

Furthermore, be aware that there is a bug in WSLg that prevents modifier keys
like [Alt Gr](https://github.com/microsoft/wslg/issues/890) from working
properly.

If you prefer Emacs or Neovim, then we recommend to install it in WSL and use
it in command line mode, not through WSLg (so starting Emacs with the `- nw`
argument).

### Recommended setup on Linux

On Linux distributions, the only real limitation is that RStudio cannot interact
with Nix shells (just like on the other operating systems), so if you want to
use RStudio then you need to install it using Nix.

You should also be aware that there is currently a bug in the RStudio Nix
package that makes RStudio ignore project-specific `.Rprofile` files, which can
be an issue if you also have a system-level library of packages. Instead, you
can sure the `.Rprofile` generated by `rix()` yourself or you can uninstall the
system-level R and library of packages.

If you use another editor, just follow the relevant instructions below; the
question you need to think about is whether you want to use Nix to install the
editor inside of the development shell or if you prefer to install your editor
yourself using your distribution's package manager, and configure it to interact
with Nix shells. We recommend the latter option, regardless of the editor you
choose.

### RStudio

RStudio **must** be installed by Nix in order to *see* and use Nix shells. So
you cannot use the RStudio already installed on your computer to work with Nix
shells. This means you need to set `ide = "rstudio"` if you wish to use RStudio.

You should also be aware that there is currently a bug in the RStudio Nix
package that makes RStudio ignore project-specific `.Rprofile` files, which can
be an issue if you also have a system-level library of packages. Instead, you
can sure the `.Rprofile` generated by `rix()` yourself or you can uninstall the
system-level R and library of packages.

#### RStudio on macOS

To use RStudio on macOS simply use `ide = "rstudio"`, but be aware that this
will only work for R version 4.4.3 at least, or for a date on or after the
2025-02-28. If you don't need to work with older versions of R or older date,
RStudio is an appropriate choice. Then, build the environment using `nix-build`
and drop into the shell using `nix-shell`. Then, type `rstudio` to start
RStudio. If you wish, you can even put the `rstudio`
command in the shell hook to start it immediately as you run `nix-shell`.

#### RStudio on Linux or Windows

To use RStudio on Linux or Windows simply use `ide = "rstudio"`. Then, build the
environment using `nix-build` and drop into the shell using `nix-shell`. Then,
type `rstudio` to start RStudio.

If you plan to use RStudio on Ubuntu, then you need further configuration to
make it work, because of newly introduced sandboxing features in Ubuntu 24.04.
You will need to create an RStudio-specific AppArmor profile. To do so
create this apparmor profile:

```bash
sudo nano /etc/apparmor.d/nix.rstudio
```

Populate it with:

```bash
profile nix.rstudio /nix/store/*-RStudio-*-wrapper/bin/rstudio flags=(unconfined) {
    userns,
}
```

Save it, load the profile and start RStudio:

```bash
sudo apparmor_parser -r /etc/apparmor.d/nix.rstudio
sudo systemctl reload apparmor
```

You can now start RStudio from the activated Nix shell.

On Windows, you need to have `WSLg` enabled, which should be the case on the
latest versions of Windows. If you wish, you can even put the `rstudio` command
in the shell hook to start it immediately as you run `nix-shell`.

On Linux and WSL, depending on your desktop environment, and for older versions
of RStudio, you might see the following error message when trying to launch
RStudio:

```bash
qt.glx: qglx_findConfig: Failed to finding matching FBConfig for QSurfaceFormat(version 2.0, options QFlags<QSurfaceFormat::FormatOption>(), depthBufferSize -1, redBufferSize 1, greenBufferSize 1, blueBufferSize 1, alphaBufferSize -1, stencilBufferSize -1, samples -1, swapBehavior QSurfaceFormat::SingleBuffer, swapInterval 1, colorSpace QSurfaceFormat::DefaultColorSpace, profile  QSurfaceFormat::NoProfile)
Could not initialize GLX
Aborted (core dumped)
```

in this case, run the following before running RStudio:

```bash
export QT_XCB_GL_INTEGRATION=none
```

To use GitHub Copilot with RStudio, follow these
[instructions](https://docs.posit.co/ide/user/ide/guide/tools/copilot.html).

### VS Code or Positron

Positron is a fork of VS Code made by Posit and tailored for data science.
Henceforth, I will refer to both editors simply as *Code*.

The same instructions apply whether your host operating system is Linux, macOS
or Windows. The first step is of course to install Code on your operating system
using the usual means of installing software.

If you're on Windows, install Code on Windows, not in WSL. Code on Windows is
able to interact with WSL seamlessly and before continuing here, please follow
[these
instructions](https://learn.microsoft.com/en-us/windows/wsl/tutorials/wsl-vscode)
(it’s mostly about installing the right extensions after having installed
Code).

On macOS, start by installing Code using the official `.dmg` installer. Start
Code, and then the command palette using `COMMAND-SHIFT-P`. In the search bar,
type `"Install 'positron' command in PATH"` and click on it: this will make it
possible to start Positron from a terminal.

Once Code is installed, you need to install a piece of software called `direnv`:
`direnv` will automatically load Nix shells when you open a project that
contains a `default.nix` file in an editor. It works on any operating system and
many editors support it, including Code. Follow the instructions for your
operating system [here](https://direnv.net/docs/installation.html) but if you're
using Windows, install `direnv` in WSL (even though you’ve just installed Code
for Windows), so follow the instructions for whatever Linux distribution you're
using there (likely Ubuntu), or use Nix to install `direnv` if you prefer (this
is the way I recommend to install it on macOS, unless you already use `brew`):

```bash
nix-env -f '<nixpkgs>' -iA direnv
```

This will install `direnv` and make it available even outside of Nix shells!

Then, we highly recommend to install the `nix-direnv` extension:

```bash
nix-env -f '<nixpkgs>' -iA nix-direnv
```

It is not mandatory to use `nix-direnv` if you already have `direnv`, but it'll
make loading environments much faster and seamless. Finally, if you haven't used
`direnv` before, don't forget [this last step](https://direnv.net/docs/hook.html).

Then, in Code, install the
[direnv](https://github.com/direnv/direnv-vscode) extension (and also the
WSL extension if you're on Windows, as explained in the official documentation
linked above!). Finally, add a file called `.envrc` and simply write the 
following two lines in it:

```bash
use nix
mkdir $TMP
```

in it. On Windows, *remotely connect to WSL* first, but on other operating
systems, simply open the project's folder using `File > Open Folder...` and you
will see a pop-up stating `direnv: /PATH/TO/PROJECT/.envrc is blocked` and a
button to allow it. Click `Allow` and then open an R script. You might get
another pop-up asking you to restart the extension, so click `Restart`. Be aware
that at this point, `direnv` will run `nix-shell` and so will start building the
environment. If that particular environment hasn't been built and cached yet, it
might take some time before Code will be able to interact with it. You might get
yet another popup, this time from the R Code extension complaining that R can't
be found. In this case, simply restart Code and open the project folder again:
now it should work every time. For a new project, simply repeat this process:

- Generate the project's `default.nix` file;
- Build it using `nix-build`;
- Create an `.envrc` and write the two lines from above in it;
- Open the project's folder in Code and click allow when prompted;
- Restart the extension and Code if necessary.

Another option is to create the `.envrc` file and write `use nix` in it, then
open a terminal, navigate to the project's folder, and run `direnv allow`. Doing
this before opening Code should not prompt you anymore.

If you're on Windows, using Code like this is particularly interesting, because
it allows you to install Code on Windows as usual, and then you can configure
it to interact with a Nix shell, even if it's running from WSL. This is a very
seamless experience.

Now configure VS Code to use GitHub Copilot, [click here](https://code.visualstudio.com/docs/copilot/overview)
or for Positron [click here](https://positron.posit.co/assistant.html).

## Hands-On Exercises

1. Start a temporary shell with R and `{rix}` again using
  `nix-shell -p R rPackages.rix`. Start an R session (by typing `R`)
  and then load the `{rix}` package (using `library(rix)`).
  Run the `available_dates()` function: using the latest available date,
  generate a new `default.nix`.
2. Inside of an activated shell, type `which R` and `echo $PATH`. Explore what
  is being added to your environment. What is the significance of paths like
  `/nix/store/...`?
3. Break it on purpose: generate a new environment with a wrong R package name,
  for example `dplyrnaught`. Try to build the environment. What happens?
4. Go to [https://search.nixos.org/packages](https://search.nixos.org/packages)
  and look for packages that you usually use for your projects to see if they
  are available.
